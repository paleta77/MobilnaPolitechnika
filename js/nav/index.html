<!DOCTYPE html>
<html>

<head>
	<title>Test 2</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.5.1/dist/leaflet.css"
		integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ=="
		crossorigin="" />
	<script src="https://unpkg.com/leaflet@1.5.1/dist/leaflet.js"
		integrity="sha512-GffPMF3RvMeYyc1LWMHtK8EbPv0iNZ8/oTtHPx9/cc2ILxQ+u905qIwdpULaqDkyBKgOaB57QTMg7ztg8Jm2Og=="
		crossorigin=""></script>
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-easybutton@2/src/easy-button.css">
	<script src="https://cdn.jsdelivr.net/npm/leaflet-easybutton@2/src/easy-button.js"></script>

	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" />
	<style>
		body {
			padding: 0;
			margin: 0;
		}

		html,
		body,
		#map {
			height: 100%;
			width: 100%;
		}
	</style>
</head>

<body>
	<div id="map">
	</div>

	<script>
		let showNodes = false;
		let showEdges = false;
		let map = L.map('map').setView([51.747, 19.455], 17);
		let bounds = [[51.747 - 0.003, 19.455 - 0.006], [51.747 + 0.003, 19.455 + 0.005]];
		L.tileLayer('https://c.tile.openstreetmap.org/{z}/{x}/{y}.png', {
			attribution: '&copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors',
			attributionControl: false,
			maxNativeZoom: 19,
			maxZoom: 22,
			minZoom: 18,
			id: 'mapbox.streets',
			bounds: bounds,
		}).addTo(map);

		map.setMaxBounds(bounds);

		let imageBounds = [[51.74542, 19.45311], [51.74867, 19.45811]];

		var floors = [0, 1, 2].map((i) => L.imageOverlay(`floor${i}.png`, imageBounds));

		let floor_idx = 2;
		floors.forEach((e) => e.addTo(map));

		let button_up = L.easyButton('fa-arrow-up', (btn, map) => changefloor(1));
		let button_down = L.easyButton('fa-arrow-down', (btn, map) => changefloor(-1));
		L.easyBar([button_up, button_down]).addTo(map);

		let nodes = [];
		let edges = [];
		let nodesLayer = L.layerGroup().addTo(map);

		let path = [];
		let pathLayer = L.layerGroup().addTo(map);
		let markersLayer = L.layerGroup().addTo(map);

		map.on('click', (e) => {
			console.log("a");
			//let circle = L.circle(e.latlng, { radius: 0.5 }).on("click", (e) => { L.DomEvent.stopPropagation(e); console.log(e); });
			//nodes.push({ floor: floor_idx, x: e.latlng.lat, y: e.latlng.lng });
			//nodesLayer.addLayer(circle);
		});

		function loadNodes() {
			let request = new XMLHttpRequest();
			request.responseType = 'text';

			request.open('GET', 'nav.json');
			request.onload = function () {
				var data = JSON.parse(request.responseText);
				//console.log(data);
				nodes = data.points;
				edges = data.edges;
				for (let node of nodes) {
					node.neighbors = [];
				}
				for (let edge of edges) {
					let a = nodes[edge.a];
					let b = nodes[edge.b];
					let len = distance(a, b) * 1000;
					a.neighbors.push({ b: b, len: len });
					b.neighbors.push({ b: a, len: len });
				}
				let searchParams = new URLSearchParams(window.location.search);
				let start = searchParams.get('start') || 59;
				let end = searchParams.get('end') || 1;

				dijkstra(nodes[start], nodes[end]);
				changefloor(0);
			}
			request.send();
		}

		loadNodes();

		let last = null;

		function changefloor(change) {

			map.removeLayer(floors[floor_idx]);
			floor_idx += change;
			floor_idx = Math.min(Math.max(floor_idx, 0), 2);
			floors[floor_idx].addTo(map);

			nodesLayer.clearLayers();
			pathLayer.clearLayers();
			markersLayer.clearLayers();

			if (showNodes) {
				for (let idx in nodes) {
					let point = nodes[idx];
					if (point.floor === floor_idx) {
						let circle = L.circle([point.x, point.y], { radius: 0.5 });
						circle.on("click", (e) => {
							L.DomEvent.stopPropagation(e);
							if (last === null) {
								last = e.target.my_idx;
							}
							else {
								edges.push({ a: last, b: e.target.my_idx });
								last = null;
								changefloor(0);
							}
						});
						circle.my_idx = idx;
						nodesLayer.addLayer(circle);
					}
				}
			}

			if (showEdges) {
				for (let idx in edges) {
					let edge = edges[idx];
					let a = nodes[edge.a];
					let b = nodes[edge.b];
					if (a.floor === floor_idx)
						pathLayer.addLayer(L.polyline([[a.x, a.y], [b.x, b.y]]));
				}
			}
			if (path.length >= 2) {
				for (let i = 1; i < path.length; i++) {
					let a = path[i - 1];
					let b = path[i];
					if (a.floor === floor_idx || b.floor === floor_idx)
						pathLayer.addLayer(L.polyline([[a.x, a.y], [b.x, b.y]]));
				}
				if (path[0].floor === floor_idx)
					markersLayer.addLayer(L.marker([path[0].x, path[0].y]));
				if (path[path.length - 1].floor === floor_idx)
					markersLayer.addLayer(L.marker([path[path.length - 1].x, path[path.length - 1].y]));
			}
		}

		function smallest(set) {
			let minimum = 0;

			for (let i = 1; i < set.length; i++) {
				if (set[i].dist < set[minimum].dist)
					minimum = i;
			}
			return minimum;
		}

		function dijkstra(start, end) {
			let q = [];

			for (let i = 0; i < nodes.length; i++) {
				let node = nodes[i];
				node.dist = Infinity;
				node.prev = null;
				q.push(node);
			}

			start.dist = 0;

			while (q.length > 0) {
				u_idx = smallest(q);
				u = q[u_idx];
				q.splice(u_idx, 1);

				for (let i = 0; i < u.neighbors.length; i++) {
					let v = u.neighbors[i];
					let alt = u.dist + v.len;
					if (alt < v.b.dist) {
						v.b.dist = alt;
						v.b.prev = u;
					}
				}
			}

			s = [];
			u = end;
			if (u.prev != null || u === start) {
				while (u != null) {
					s.unshift(u)
					u = u.prev
				}
			}

			path = s;
		}

		function distance(start, end) {
			var p = 0.017453292519943295;    // Math.PI / 180
			var c = Math.cos;
			var a = 0.5 - c((end.x - start.x) * p) / 2 +
				c(start.x * p) * c(end.x * p) *
				(1 - c((end.y - start.y) * p)) / 2;

			return 12742 * Math.asin(Math.sqrt(a)); // 2 * R; R = 6371 km
		}
	</script>
</body>

</html>