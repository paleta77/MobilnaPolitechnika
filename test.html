<!DOCTYPE html>
<html>

<head>
	<title>CTI NAV</title>
	<style>
	svg #layer5 {
		transform: perspective(10000px) rotateX(68.4deg) translateZ(-20px);
	}
	svg #g5174 {
		transform: perspective(10000px) rotateX(68.4deg) translateZ(-50px);
	}
	svg #g5232 {
		transform: perspective(10000px) rotateX(68.4deg) translateZ(-50px);
	}
	</style>
</head>

<body>
	<object data="floor.svg" type="image/svg+xml" id="floor" xmlns="http://www.w3.org/2000/svg"
		xmlns:xlink="http://www.w3.org/1999/xlink"></object>
	<div class="slidecontainer">
		<input type="range" min="1" max="1" value="1" id="floorSlider" onchange="changeFloor()">
	</div>
	<div id="buttons"></div>
	<textarea id="edges" rows="30" cols="30"></textarea>
	<button onclick="loadMesh()">Load</button>


	<script>
		var last = null;
		var mesh = { nodes: [], edges: [] }
		var a = document.getElementById("floor");
		var edges = document.getElementById("edges");
		var buttons = document.getElementById("buttons");
		var svgDoc;
		var foreground;
		var background;
		var floors;
		var startNode;

		var lineStyle = "stroke:#0000FF;stroke-width:0.6;stroke-linecap:square;stroke-linejoin:miter;stroke-miterlimit:4;";
		var pathStyle = "stroke:#00FF00;stroke-width:0.6;stroke-linecap:square;stroke-linejoin:miter;stroke-miterlimit:4;";

		a.addEventListener("load", function () {

			svgDoc = a.contentDocument;
			buttons.style.display = 'none';

			foreground = svgDoc.getElementById("layer4");
			background = svgDoc.getElementById("layer7");
			floors = []
			var floors_el = svgDoc.getElementById("layer6");

			for (var child = floors_el.firstChild; child !== null; child = child.nextSibling) {
				if (child.localName == "g") {
					floors.push(child);
					//child.style.display = "none";
					child.style.display = "block";
					child.style.transform = " perspective(10000px) rotateX(68.4deg) translateZ("+(-70 + 30 * (floors.length - 1))+"px)";
				}
			}
			var slider = document.getElementById("floorSlider");
			slider.max = floors.length;
			changeFloor();

			var delta = svgDoc.getElementsByTagName("circle");
			for (var i = 0; i < delta.length; i++) {
				delta[i].style.display = 'none';
				var title = delta[i].getElementsByTagName("title");
				var name = null;
				if (title.length > 0) {
					name = title[0].innerHTML;
				}

				var floor = parseInt(delta[i].parentNode.parentNode.getAttribute("inkscape:label").replace("Floor", ""));

				var node = { element: delta[i], id: name, floor: floor, x: delta[i].cx.baseVal.value, y: delta[i].cy.baseVal.value, neighbors: [] };
				delta[i].myNode = node;
				mesh.nodes.push(node);

				if (name != null && name != "START") {
					var btn = document.createElement("button");
					btn.innerHTML = name;
					btn.myNode = node;
					btn.onclick = function (e) { dijkstra(startNode, e.target.myNode) };
					buttons.appendChild(btn);
				}

				if (name == "START")
					startNode = node;

				// TODO: remove y offset of 177
				/*delta[i].addEventListener("mousedown", function (e) {
					//alert("ok");
					if (last == null)
						last = e.target;
					else {
						console.log(last.id + " " + e.target.id);
						var el = getChildWithAttribute(floors[slider.value - 1], "inkscape:label", "mesh");
						el.appendChild(getNode('line', { x1: last.cx.baseVal.value, y1: last.cy.baseVal.value - 177, x2: e.target.cx.baseVal.value, y2: e.target.cy.baseVal.value - 177, style: lineStyle }));
						var len = Math.sqrt(Math.pow(last.cx.baseVal.value - e.target.cx.baseVal.value, 2) + Math.pow(last.cy.baseVal.value - e.target.cy.baseVal.value, 2));
						edges.value += last.id + " " + e.target.id + " " + len + " " + (slider.value - 1) + "\n";

						last = null;
					}
				}, false);*/
			}
		}, false);


		function getChildWithAttribute(parent, el, name) {
			for (var child = parent.firstChild; child !== null; child = child.nextSibling) {
				if (child.nodeName != "#text") {
					if (child.getAttribute(el) == name) {
						return child;
					}
				}
			}
			return null;
		}

		function getNode(n, v) {
			n = document.createElementNS("http://www.w3.org/2000/svg", n);
			for (var p in v)
				n.setAttributeNS(null, p, v[p]);
			return n
		}

		function loadMesh() {
			buttons.style.display = 'block';
			var lines = edges.value.split(/\n/);

			lines.forEach(function (el) {
				var parts = el.split(' ')
				if (parts.length >= 3) {
					var a = svgDoc.getElementById(parts[0]);
					var b = svgDoc.getElementById(parts[1]);
					var len = parseFloat(parts[2])
					var layer = parseInt(parts[3])
					var el = getChildWithAttribute(floors[layer], "inkscape:label", "mesh");
					el.appendChild(getNode('line', { x1: a.cx.baseVal.value, y1: a.cy.baseVal.value, x2: b.cx.baseVal.value, y2: b.cy.baseVal.value, style: lineStyle }));

					a.myNode.neighbors.push({ b: b.myNode, len: len });
					b.myNode.neighbors.push({ b: a.myNode, len: len });
					mesh.edges.push({ a: a.myNode, b: b.myNode, len: len });
				}
			});
		}

		function smallest(set) {
			var minimum = 0;

			for (var i = 1; i < set.length; i++) {
				if (set[i].dist < set[minimum].dist)
					minimum = i;
			}
			return minimum;
		}

		function dijkstra(start, end) {
			q = []

			for (var i = 0; i < mesh.nodes.length; i++) {
				var node = mesh.nodes[i];
				node.dist = Infinity;
				node.prev = null;
				q.push(node);
			}

			start.dist = 0;

			while (q.length > 0) {
				u_idx = smallest(q);
				u = q[u_idx];
				q.splice(u_idx, 1);

				for (var i = 0; i < u.neighbors.length; i++) {
					var v = u.neighbors[i];
					var alt = u.dist + v.len;
					if (alt < v.b.dist) {
						v.b.dist = alt;
						v.b.prev = u;
					}
				}
			}

			s = [];
			u = end;
			if (u.prev != null || u === start) {
				while (u != null) {
					s.unshift(u)
					u = u.prev
				}
			}


			for (var i = 0; i < floors.length; i++) {
				var el = getChildWithAttribute(floors[i], "inkscape:label", "mesh");
				while (el.firstChild) {
					el.firstChild.remove();
				}
			}

			for (var i = 0; i < s.length - 1; i++) {
				var a = s[i];
				var b = s[i + 1];
				if (a.floor == b.floor) {
					var el = getChildWithAttribute(floors[a.floor], "inkscape:label", "mesh");
					el.appendChild(getNode('line', { x1: a.x, y1: a.y - 177, x2: b.x, y2: b.y - 177, style: pathStyle }));
				}
				else {
					var el = getChildWithAttribute(floors[b.floor], "inkscape:label", "mesh");
					el.appendChild(getNode('line', { x1: a.x, y1: a.y - 177, x2: b.x, y2: b.y - 177, style: pathStyle }));
				}
			}
		}

		function changeFloor() {
			var slider = document.getElementById("floorSlider");
			slider.value
			for (var i = 0; i < floors.length; i++) {
				/*if (i == slider.value - 1)
					floors[i].style.display = 'block';
				else
					floors[i].style.display = 'none';*/
			}
		}


	</script>
</body>

</html>